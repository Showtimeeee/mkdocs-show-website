# Паттерн Proxy

**Proxy (Заместитель)** — это структурный паттерн проектирования, который предоставляет объект-заместитель для контроля доступа к другому объекту. Proxy позволяет добавлять дополнительную логику при обращении к объекту, не изменяя его исходный код.

---

## Основная концепция

Суть паттерна заключается в том, что:
- **Proxy** выступает в роли посредника между клиентом и реальным объектом (Subject).
- Клиент взаимодействует с Proxy так, как будто это реальный объект.
- Proxy может добавлять дополнительную логику (например, проверку прав, кеширование, ленивую инициализацию) перед или после передачи запроса реальному объекту.

---

## Преимущества использования

1. **Контроль доступа**
   - Proxy может ограничивать или разрешать доступ к реальному объекту (например, по правам пользователя).

2. **Ленивая инициализация**
   - Реальный объект создаётся только тогда, когда он действительно нужен (например, при первом обращении).

3. **Кеширование**
   - Proxy может кешировать результаты работы реального объекта, чтобы избежать повторных вычислений.

4. **Удалённое взаимодействие**
   - Proxy может скрывать сложность работы с удалёнными объектами (например, сетевыми ресурсами).

5. **Логирование и мониторинг**
   - Proxy может вести журнал обращений к объекту или собирать статистику.

---

## Ключевые компоненты

1. **Subject (Интерфейс)**
   - Общий интерфейс для Proxy и RealSubject, чтобы клиент мог работать с ними одинаково.

2. **RealSubject (Реальный объект)**
   - Объект, к которому Proxy предоставляет доступ.

3. **Proxy (Заместитель)**
   - Хранит ссылку на RealSubject.
   - Управляет доступом к RealSubject и может добавлять дополнительную логику.

4. **Client (Клиент)**
   - Работает с Proxy через интерфейс Subject, не зная, работает ли он с Proxy или RealSubject напрямую.

---

## Пример: Виртуальный Proxy для загрузки изображений

Предположим, у нас есть приложение, которое отображает изображения. Загрузка больших изображений может занимать много времени и ресурсов, поэтому мы хотим загружать их только при необходимости.

### Без Proxy

```python
class Image:
    def __init__(self, filename):
        self.filename = filename
        self.load_image()

    def load_image(self):
        print(f"Загрузка изображения {self.filename}...")

    def display(self):
        print(f"Отображение изображения {self.filename}")

# Клиентский код
image = Image("photo.jpg")
image.display()
```
В этом случае изображение загружается сразу при создании объекта, даже если оно не нужно прямо сейчас.

---

### С Proxy

```python
class Image:
    def __init__(self, filename):
        self.filename = filename
        self.load_image()

    def load_image(self):
        print(f"Загрузка изображения {self.filename}...")

    def display(self):
        print(f"Отображение изображения {self.filename}")

class ProxyImage:
    def __init__(self, filename):
        self.filename = filename
        self.real_image = None

    def display(self):
        if self.real_image is None:
            self.real_image = Image(self.filename)
        self.real_image.display()

# Клиентский код
proxy_image = ProxyImage("photo.jpg")
# Изображение ещё не загружено
proxy_image.display()  # Теперь загружается и отображается
proxy_image.display()  # Просто отображается, без повторной загрузки
```

---

## Когда использовать

1. **Ленивая инициализация**
   - Когда создание объекта требует много ресурсов, и его нужно отложить до момента первого использования.

2. **Контроль доступа**
   - Когда нужно ограничить доступ к объекту по каким-либо критериям (например, правам пользователя).

3. **Удалённое взаимодействие**
   - Когда работа с объектом требует сетевых запросов или других сложных операций.

4. **Логирование и мониторинг**
   - Когда нужно вести журнал обращений или собирать статистику.

---

## Лучшие практики

1. **Соблюдайте интерфейс Subject**
   - Proxy должен реализовывать тот же интерфейс, что и RealSubject, чтобы клиент не замечал разницы.

2. **Не перегружайте Proxy**
   - Proxy должен решать одну конкретную задачу (например, только ленивая инициализация или только контроль доступа).

3. **Используйте Proxy для оптимизации**
   - Например, для кеширования результатов или отложенной загрузки.

---

## Альтернативы и дополнения

1. **Decorator Pattern**
   - Если нужно динамически добавлять функциональность объекту, не изменяя его класс.

2. **Adapter Pattern**
   - Если нужно адаптировать интерфейс одного класса к другому.

3. **Facade Pattern**
   - Если нужно упростить работу с целой подсистемой, а не с одним объектом.

---

## Пример из жизни: Банковская карта

Представьте, что у вас есть банковская карта. Сами деньги хранятся на счёте в банке (RealSubject), но вы взаимодействуете с ними через карту (Proxy). Карта позволяет вам снимать деньги, оплачивать покупки, но при этом банк может накладывать ограничения (например, лимит на снятие наличных или проверку PIN-кода). Карта скрывает от вас сложность работы с банковской системой и предоставляет удобный интерфейс.

---

## Вывод

**Proxy** — это универсальный паттерн, который позволяет контролировать доступ к объектам, оптимизировать их использование и добавлять дополнительную логику без изменения исходного кода. Он особенно полезен в ситуациях, когда создание или работа с объектом требует значительных ресурсов или когда нужно ограничить доступ к объекту по каким-либо критериям. Proxy делает код более гибким, безопасным и эффективным.