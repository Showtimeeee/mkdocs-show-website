# Паттерн Decorator (Декоратор)

**Decorator (Декоратор)** — это структурный паттерн проектирования, который позволяет динамически добавлять объектам новую функциональность, оборачивая их в специальные "обёртки". Паттерн предоставляет гибкую альтернативу наследованию для расширения поведения объектов.

---

## Основная концепция

- **Декоратор** — это объект, который оборачивает другой объект, добавляя ему новые свойства или поведение.
- Клиент работает с декорированным объектом через общий интерфейс, не замечая разницы.
- Декораторы можно комбинировать, создавая цепочки обёрток.

---

## Зачем нужен паттерн Decorator

1. **Гибкое расширение функциональности**
   - Позволяет добавлять новые возможности объектам на лету, без изменения их классов.

2. **Избегание взрывного роста классов**
   - Вместо создания множества подклассов для каждой комбинации функций, используются декораторы.

3. **Соблюдение принципа открытости/закрытости**
   - Классы остаются открытыми для расширения, но закрытыми для модификации.

---

## Ключевые компоненты

1. **Component (Интерфейс компонента)**
   - Общий интерфейс для всех конкретных компонентов и декораторов.

2. **ConcreteComponent (Конкретный компонент)**
   - Исходный объект, к которому будут применяться декораторы.

3. **Decorator (Базовый декоратор)**
   - Класс, реализующий интерфейс Component и содержащий ссылку на оборачиваемый объект.
   - Делегирует основную работу обёрнутому объекту.

4. **ConcreteDecorator (Конкретный декоратор)**
   - Добавляет новую функциональность, вызывая методы родительского декоратора и/или обёрнутого объекта.

---

## Пример: Декорирование напитков в кофейне

Предположим, у нас есть базовые напитки (кофе, чай), к которым можно добавлять различные добавки (молоко, сахар, шоколад). Каждая добавка изменяет стоимость и описание напитка.

### 1. Интерфейс компонента

```python
class Beverage:
    def cost(self) -> float:
        pass

    def description(self) -> str:
        pass
```

### 2. Конкретные компоненты

```python
class Coffee(Beverage):
    def cost(self) -> float:
        return 50

    def description(self) -> str:
        return "Кофе"

class Tea(Beverage):
    def cost(self) -> float:
        return 30

    def description(self) -> str:
        return "Чай"
```

### 3. Базовый декоратор

```python
class BeverageDecorator(Beverage):
    def __init__(self, beverage: Beverage):
        self._beverage = beverage

    def cost(self) -> float:
        return self._beverage.cost()

    def description(self) -> str:
        return self._beverage.description()
```

### 4. Конкретные декораторы

```python
class MilkDecorator(BeverageDecorator):
    def cost(self) -> float:
        return self._beverage.cost() + 10

    def description(self) -> str:
        return self._beverage.description() + ", с молоком"

class SugarDecorator(BeverageDecorator):
    def cost(self) -> float:
        return self._beverage.cost() + 5

    def description(self) -> str:
        return self._beverage.description() + ", с сахаром"
```

---

### Клиентский код

```python
coffee = Coffee()
print(coffee.description(), "-", coffee.cost())

coffee_with_milk = MilkDecorator(coffee)
print(coffee_with_milk.description(), "-", coffee_with_milk.cost())

coffee_with_milk_and_sugar = SugarDecorator(coffee_with_milk)
print(coffee_with_milk_and_sugar.description(), "-", coffee_with_milk_and_sugar.cost())
```

**Вывод:**
```
Кофе - 50
Кофе, с молоком - 60
Кофе, с молоком, с сахаром - 65
```

---

## Когда использовать паттерн Decorator

- **Динамическое добавление функциональности**
  Когда нужно добавлять новые возможности объектам на этапе выполнения.

- **Избегание наследования**
  Когда расширение через наследование приводит к взрывному росту классов.

- **Соблюдение принципа открытости/закрытости**
  Когда важно не изменять существующие классы, но расширять их поведение.

---

## Преимущества паттерна

- **Гибкость**
  Можно динамически добавлять, удалять или изменять декораторы.

- **Расширяемость**
  Легко добавлять новые декораторы без изменения существующего кода.

- **Соблюдение принципов SOLID**
  Открытость для расширения, закрытость для модификации.

---

## Недостатки паттерна

- **Сложность отладки**
  Цепочки декораторов могут усложнить поиск ошибок.

- **Избыточность**
  Слишком много декораторов могут сделать код трудным для понимания.

---

## Пример из жизни: Одежда

Представьте, что у вас есть человек (ConcreteComponent), и вы можете "одевать" его в разную одежду (ConcreteDecorator): куртку, шарф, шапку. Каждый предмет одежды добавляет новые свойства (тепло, стиль) и может комбинироваться с другими. Вы можете надеть только куртку, или куртку + шарф, или всё вместе — при этом сам человек не меняется, а только оборачивается в новые слои.

---

## Вывод

**Decorator** — это мощный и гибкий паттерн, который позволяет расширять функциональность объектов динамически, не изменяя их исходный код. Он особенно полезен в ситуациях, когда нужно избежать создания множества подклассов или когда функциональность должна добавляться и изменяться на этапе выполнения. Декораторы делают код более модульным, поддерживаемым и открытым для расширения.

